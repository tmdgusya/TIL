### 트랜잭션을 다룰 수 있는 테이블을 작성해 보자

- 데이터베이스를 사용하는 실제 시스템이나 애플리케이션에서는 단일 쿼림나으로 조작하는 일은 거의 없고, 복수의 쿼리를 연속적으로 사용해 일관성 있는 형태의 한 단위로 취급해야 합니다.

```sql
create table t1(i1 int not null primary key, v2 varchar(20)) engine = innodb;
```

- InnoDB 형 테이블 t1이 작성된다.

```sql
insert into t1 values(1, 'Firebird');
```

- 해당 명령을 입력한다.

```sql
show create table t1;
```

## 예시

```sql
mysql> create view User as select id, name, city from User;
ERROR 1050 (42S01): Table 'User' already exists
mysql> create view UservieW as select id, name, city from User;
Query OK, 0 rows affected (0.01 sec)

mysql> create view Userview as select id, name, city from User;
Query OK, 0 rows affected (0.02 sec)

mysql> create table t1(i1 int not null primary key, v2 varchar(20)) engine = innodb;
Query OK, 0 rows affected (0.07 sec)

mysql> insert into t1 values(1, 'Firebird');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t1 values(2, 'Bluebird');
Query OK, 1 row affected (0.00 sec)

mysql> show create table t1;
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                                                                      |
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| t1    | CREATE TABLE `t1` (
  `i1` int NOT NULL,
  `v2` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`i1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |
+-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

# 트랜잭션이란 ?

- 복수 쿼리를 일관된 형태의 한덩어리 묶은 것. (하나의 비즈니스 로직에서 수행되는 쿼리들이 하나의 트랜잭션이라고 생각하면 됨) → 결국 읽기 같은것도 하나의 트랜잭션인데 ANSI 기준에서 다른 트랜잭션의 영향을 닥아도 되는 기준이므로, 다른 책에서 트랜잭션으로 설명안한듯 하다.
    - COMMIT : 비즈니스 로직이 정상적으로 수행되어, 영속적으로 반영되는 것
    - ROLLBACK : 비즈니스 로직 도중에 오류 발생시, 초기 데이터베이스 상태로 롤백되는 것

### MySQL의 경우

- mySQL 의 경우 MyISAM형(**트랜잭션을 사용할 수 없는 단순한 구조**) 와 InnoDB(**트랜잭션을 사용할 수 있는 구조**)

### 트랜잭션

- **원자성** : 데이터의 변경을 수반하는 일련의 데이터 조작이 전부 성공할지 / 전부 실패할지를 보증하는 구조

    중간에 절차상의 오류가 나지않고, 정상적으로 수행되면 **COMMIT** 되고, 아닐 경우에는 **ROLLBACK** 되어야 함. 

- **일관성** : 데이터베이스 에는 데이터베이스 오브젝트에 대해 각종 정합성 제약을 추가할 수 있는데, 이는 일련의 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는 즉 **일관성을 유지하기 위한 구조입니다. 예를들면 우리가 DB 에 id 에 constraint 로 unique option을 걸면 DB 에서 id 는 unique 하게 일관적으로 구성됨. 그리고 우리가 설정하는 value 의 type 등등도 일관성을 지키기 위한 행위이다. (ex. number 가 String type 으로 변경되지 않는 것들)**
- **고립성** : 고립성이란 일련의 데이터 조작을 **복수의 사용자가 동시에 실행**해도 **'각각의 처리가 모순없이 실행되는 것을 보증한다'** 는 것입니다. 만약에 우리가 전화번호부에 10번을 업데이트 하는데, A 와 B 가 동시에 접근하여 10 가 11로 변경하려고 하려면, 어떤 것으로 Overwrite 될지 알 수 없으므로, DB 에서는 **Lock** 을 걸어서 후속처리를 Block 해주는 방법을 이용합니다.
    - MySQL 에서는 트랜잭션을 처리를 할 때 주로 행 단위의 잠금 기능을 이용한다.
    - **InnoDB**형의 테이블은 MVCC 구조로 동작하기 때문에, Write 의 경우에는 Block 시키지 않습니다. 그래서 참조하는 사용자가 많은 경우 동시성, 병렬성을 높일 수 있습니다.
    - 그니까 결국에 DB에 모순이 일어날 수 있는 상황을 방지하려면, **병렬로 실행되지 않는 상태**를 뜻한다.
    - **DBMS 에서는 이를 격리수준으로 구현하고 제공하는 것이 직렬화 기능이다.**
    - 하지만 직렬화 가능의 고립성에서는 항상 동시에 동작하는 트랙잭션이 1개의 이미지가 되어 성능면에서 실용적이지 않습니다.

    ### ANSI 가 정의하는 격리 수준 (자신이 트랜잭션의 영향을 받는 것을 허용하는 4단계)

    - 커밋되지 않은 읽기
    - 커밋된 읽기
    - 반복 읽기
    - 직렬화 기능

    ### 격리 수준의 완화에 따라 일어나는 현상

    - **Dirty Read** : 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상이다. 예를 들면, 사용자가 A가 값을 변경하고, 아직 커밋하지 않아도 사용자 B가 변경한 후의 값을 읽는 것을 가리킨다. (**커밋되지 않은 읽기**), 확장전의 더럽혀진 데이터를 읽는 것에서 붙여진 이름이다.
    - **애매한 읽기(Fuzy)** : 어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽어 들일때 2회 이후의 결과와 1회때와 다른 현상이다. 예를 들면, **최초에 사용자 A가 빈 싱글룸 수 '10' 을 읽고**, 그 후 사용자 B가 값을 **'9'로 변경해 커밋**했다고 하자. 계속해서 사용자 A가 SELECT를 다시 실행하면 최초에 SELECT 했던 '10' 이 아닌 변경 후의 '9' 를 읽어 들이게 된다.
    - **팬텀 읽기(Phantom Read)** : 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상이다. 최초에 사용자 A가 범위 검색(예를 들면, 빈 싱글룸 수가 10이상의 호텔)을 수행 후 3행을 읽었다고 가정 하자. 계속해서 사용자 B가 막 그 범위에 들어가는 데이터 1행을 INSERT 하고, 커밋도 실행했다. 계속해서 사용자 A가 다시 같은 SELECT 문을 실행하면 최초에 SELECT 해서 얻었던 3행이 아닌 4행이 선택된다. 이 처럼 나타나거나 사라지는 데이터가 유령과 닮아서 붙여진 이름이다.
- **지속성** : 일련의 비즈니스 로직을 완료하고 COMMIT 된 데이터들이 영구적으로 저장되어 그 결과를 잃지 않도록 하는 속성

## 다른 커넥션에서는 어떻게 보일지 생각해보자

- 한개의 커넥션에서 작성한 테이블과, 이 테이블에 저장한 데이터를 다른 커넥션에서 볼 수 있다.
- 기본적으로는 **데이터 정의 언어(DDL)**에 따른 테이블 작성과, **데이터 조작언어**(DML)에 의한 데이터 저장은 트랜잭션이 커밋되기 전까지는 다른 커넥션에서 보이지 않으나, 다른 커넥션에서 보이는 이유는 아래와 같다.
- **DDL에 따른 암묵적인 커밋**
    - MySQL 이나 Oracle 에서는 CREATE 등등의 DDL 이 발생했을때, 암묵적인 커밋이 발생합니다.
- **오토커밋 설정**
    - 트랜잭션의 개시가 명시적으로 지정되지 않았을때 트랜잭션을 구별하는 방법으로 다음 2가지 방법을 이용합니다.
        - 하나의 SQL 문이 하나의 트랜잭션으로 구분된다.
        - 사용자가 COMMIT 또는 ROLLBACK 을 실행하기 까지가 하나의 트랜잭션이 된다.

### PS

- **DDL** : 데이터를 저장하는 그릇인 스키마 또는 테이블을 작성할 때 쓰이는 언어로, **CREATE, ALTER, DROP** 등이 있습니다.
- **DML** : DML은 테이블의 행을 검색하거나 변경하는데 사용할 수 있습니다. DML로 구분된 명령에는 **SELECT, INSERT, DELETE** 등이 있습니다.
- **DCL** : 데이터베이스에서 실행한 변경을 확정하거나 취소하는데 사용합니다. 이번 장에서 소개한 COMMIT 이나 ROLLBACK은 DCL의 일종입니다.
