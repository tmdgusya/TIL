# 돌아보며..

# 서론

컴퓨터 공학 전공시간에 기본적으로 배웠던, 논리 연산을 직접 자바로 만들어 보는 과정을 하였다. <br>
사실 컴퓨터 공학 1학년 전공으로 들을땐, 그냥 대충 이런 연산이 있구나 하고 넘어갔는데, 확장성 있게 설계하는데 꽤나 애를 먹었다. <br>
팀원들과 주로 스터디를 하여 코드 작성하는 시간이 길었는데 되게 재밌고, **혼자하는것 보다 코드를 깔끔하게 적어야지** 하는 의식에 내 코드가 클린하게 변해가는걸 느꼈다. <br>
그리고 음 나는 이렇게 생각했는데, **다른 사람은 이렇게 생각했구나! 그럼 뭐가 더 효율적인 코드일까?** 라고 생각하며 남들 코드를 보다보니, 
내 코드에서 이곳저곳 고칠 곳이 보였다. 그래서 코드를 이곳저곳 고칠 수 있었고, 꽤나 협업으로 인해 얻을 수 있는 좋은 경험이였다.
그래서 오늘은 기술적인 것보다 어떻게 하면 코드를 깔끔히 적을 수 있을까? 란 것에대한 회고를 조금 해보려고 한다.

## 노력한점

- 최대한 함수, 변수, 클래스명을 주석없이도 인식할 수 있게끔 했다. 예를 들면 BitAdder Class 에는 아래와 같이 CARRY, SUM 에 대해 상수로 설정하여
그냥 단순히 0, 1 로 적는 것보다. 아래와 같이 적었다.

```java
    public boolean[] halfAdder(boolean inputBit, boolean inputBit_){
        boolean[] answer = new boolean[2];
        answer[0] = getCarry(byteA, byteB);
        answer[1] = getSum(byteA, byteB);
        return answer;
    }
```

**클린코드!**

```java
    private final int CARRY = 0;
    private final int SUM = 1;

    public boolean[] halfAdder(boolean inputBit, boolean inputBit_){
        boolean[] answer = new boolean[2];
        answer[CARRY] = getCarry(byteA, byteB);
        answer[SUM] = getSum(byteA, byteB);
        return answer;
    }
```

이게 더 명확한것 같다. answer 배열에 0, 1 보다는 CARRY, SUM 상수를 넣으면 누가 읽어도 array[0] 과 array[1]이 어떤 걸 의미하는지 알 수 있겠다는 생각이 들었다.

#### isPreCalcResultOfCarry

함수명을 조금 길게 적더라도 어떤 작업을 하는 함수인지 알 수 있도록 하였다. <br>
비트 연산과정에서 앞연산에서 Carry 가 오는지 알 수 있도록 하기 위해, 함수 이름을 동작하는것을 그대로 적어보았다.


#### 내부 로직 처리 함수는 Private 으로

아래의 함수들은 Main 함수들의 로직을 돕기위한 Sub 함수들이다. 해당 함수들은 Client 에게 공개 되면, 이상한 값으로 바뀔수도 있고,
Main 함수들의 로직에도 이상한 영향을 끼칠 수도 있다고 판단되어 Private 으로 잠궈 놓았다.

```java
    private int whoIsBigLengthArray(boolean[] byteA, boolean[] byteB){
        int length;
        if(byteA.length > byteB.length){
            length = byteA.length;
        }else {
            length = byteB.length;
        }
        return (length+1);
    }
    
    private boolean getCarry(boolean byteA, boolean byteB){
        return byteA && byteB;
    }
    
    private boolean getSum(boolean byteA, boolean byteB){
        return byteA != byteB;
    }
```

#### 다른 설계 방향

음 객체적으로 설계한다면 이것저것 필드가 많아 Builder 패턴을 고려해봄이 어떨지 고민이 된다.
사실 이런곳에 Builder 패턴을 쓰는게 맞는지 모르겠어서, 공부를 조금 더 해보고 내일 고민해 봐야겠다.

## 소감

팀원들과 같이 공부하며 배울 수 있다는 건 정말 좋은 점이다. 혼자서 공부하면 발전이 같이 하는 사람에 비해 뎌뎌질 수 밖에 없다. <br>
예전에 회사에서 보았던 문구가 기억이 난다. **자신의 코드에 자신의 자존심을 걸지마라! 남의 의견을 듣고 이성적으로 검토해라!** <br>
이 말이 진정 와닿는다. 내 코드에 자존심을 걸지말자 남의 의견을 받아들이고 수용하자!