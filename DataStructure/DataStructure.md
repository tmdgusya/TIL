# DataStrucutre 를 직접 구현해보는 역할을 한다.

## 구현 원칙

- 하나의 자료구조를 설계 후 Test(Junit) 을 통해 TestCase 들을 통과시킨다. 

# 01 Stack

- pop : 스택에서 가장 위에 있는 항목을 제거한다.
- push(item) : Item 하나를 스택의 가장 윗 부분에 추가한다.
- peek() : 가장위에 있는 아이템 하나를 반환한다.
- pop() : 가장위에 있는 Item 하나를 반환하고 제거한다.

## 구현 설계 생각과정

- 데이터가 들어올때 마다 객체가 동적으로 할당되는 구조 => 따라서 연결 정보 / 위치정보 (next, top) 필요
- 같은 데이터를 보존해야 하므로 Generic 으로 설정.

## 구현 코드 / 테스트 

[코드](./src/Stack.java)

[테스트](./test/StackTest.java)

## 느낀점

클린코드 책을 완주하고 나서 적는 코드는 이전 코드보다 확실히 기능이 명확하고, 알아보기 쉽다. <br>
간단하게 구현을 잘 한것같아 기분이 좋다. 

# 02 Queue

- add() : item 을 List 의 끝 부분에 추가한다.
- remove() : 리스트의 첫번째 항목을 제거한다.
- peek() ; 큐에서 가장 위에 있는 항목을 반환한다.
- isEmpty() : 큐가 비어있을때 true를 반환한다.

## 구현 코드 / 테스트

[코드](./src/Queue.java)

[테스트](./test/QueueTest.java)

# 03 Graph

- 그래프는 정점과 간선으로 이루어진 자료구조
- 정확히는 정점간의 관계를 표현하는 조직도라고 볼수도 있다. 자바로 치면 객체끼리 관계를 표현할 수도 있을것 같다. 근데 상위 관계의 상위관계 즉 부모의 부모도있으므로 Depth 가 있는 트리구조로 발전시켜 쓰는게 맞는것 같다.
- 대표적인 예시로는 지하철 노선도, 도심의 도로 등이 있습니다.
- 그래프를 구현하는 방법에는 **인접행렬**과 **인접리스트** 방식이 있습니다.

## 용어

- 정점(Vertice) : 노드라고도 하며 정점에는 데이터가 저장됩니다.
- 간선(Edge) : 링크라고도 하며 노드간의 관계를 나타냅니다.
- 인접 노드 : 간선에 의해 연결된 노드
- 단순경로 : 경로중 반복되는 정점이 없는것, 같은 간선을 지나가지 않는 경로(한손그리기 ㅇㅇ)
- 차수 : 무방향 그래프에서 하나의 노드에 인접한 정점의 수
- 진출 차수 : 방향 그래프에서 사용되는 용어로 한 노드에서 외부로 향하는 간선의 수를 뜻합니다.
- 진입 차수 : 방향그래프에서 사용되는 용어로 외부 노드에서 들어오는 간선의 수를 뜻합니다.

## 인접행렬 방식

- 인접행렬 방식은 그래프의 노드를 2차원 배열로 만든것입니다.
- 예를 들면 노드 A 와 B 가 연결되어 있다고 하면  아래와 같이 2차원 배열로 나타내는 것이다.

```java
  A B
A 0 1
B 1 0
```

### 장점

- 2차원 배열 안에 모든 정점들의 간선 정보를 담기 때문에 배열의 위치를 확인하면 두 점에 대한 연결 정보를 조회할 때 O(1)의 시간 복잡도면 가능합니다.
- 구현이 비교적 간편합니다.

### 단점

- 모든 정점에 대해 간선 정보를 대입해야 하므로 O(n^2)의 시간복잡도가 소요됩니다.
- 무조건 2차원 배열이 필요하기에 필요 이상의 공간이 낭비됩니다.

## 인접 리스트 방식

### 장점

- 정점들의 연결 정보를 탐색할 때 O(n) 의 시간이면 가능합니다.
- 필요한 만큼의 공간만 사용하기 때문에 공간의 낭비가 적습니다.

### 단점

- 특정 두 점이 연결되었는지 확인하려면 인접행렬에 비해 시간이 오래 걸립니다.
- 구현이 비교적 어렵습니다

# 04 Tree


## 구현 코드 / 테스트

[코드](./src/Tree/BinTree.java)